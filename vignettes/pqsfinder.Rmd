---
title: "pqsfinder: User Guide"
author: "Jiří Hon, Matej Lexa, Tomáš Martínek"
date: "`r doc_date()`"
package: "`r pkg_ver('pqsfinder')`"
abstract: >
  Instructions on using `r Biocpkg("pqsfinder")` package for detecting DNA sequence patterns
  that are likely to fold into an intramolecular G-quadruplex.
vignette: >
  %\VignetteIndexEntry{pqsfinder: User Guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output: 
  BiocStyle::html_document
---

# Introduction

The main functionality of the `r Biocpkg("pqsfinder")` package is to detect DNA sequence patterns that are likely to fold into an intramolecular G-quadruplex (G4). The main idea of our algorithmic approach is based on the fact that G4 structure arise from a compact sequence motif composed from four consecutive and possibly imperfect guanine runs (G-run) interrupted by loops of arbitrary lengths. The algorithm firstly identifies four consecutive G-run sequences, in the next step it checks the potential of such G-runs to be forming stable G4 and assignes corresponding quatitative score to each. Non-overlapping potential quadruplex-forming sequences (PQS) with positive score are then reported.

It is important to note, that unlike many other approaches, our algorithm is able to detect PQS with imperfect G-runs containing bulges or mismatches and as such is more sensitive than competitive algorithms. We also believe the presented solution is the most scalable since it can be easily and quickly customizable (see chapter [Customizing detection algorithm](#customizing-detection-algorithm) for details) to detect even novel G4 types that might be discovered in the future.

# G4-quadruplex detection

As usual, before first package use, it is necessary to load the `r Biocpkg("pqsfinder")` package using the following command:

```{r pqsfinder, message=FALSE, warning=FALSE}
library(pqsfinder)
```

Identification of potential quadruplex-forming sequences (PQS) in DNA is performed using the `pqsfinder` function. This function has one required parameter representing the studied DNA sequence in the form of a `DNAString` object and several modifying options with predefined values. For complete description, please see `pqsfinder` function man page.

## Basic quadruplex detection

As a simple example, let's find all PQS in a short example DNA sequence.

```{r basic_detection, results='hold'}
seq <- DNAString("TTTTGGGCGGGAGGAGTGGAGTTTTTAACCCCCCCCAAAAATTTGGGAGGGTGGGTGGGAGAAAA")
pqs <- pqsfinder(seq, max_len = 30)
pqs
```

Detected PQS are returned in the form of a `PQSViews` class, which represents the basic container for storing a set of views on the same input sequence based on `XStringViews` object from `r Biocpkg("Biostrings")` package. Each PQS in the view is defined by start location, width and score. All these values can be accessed by standard functions `start(x)`, `width(x)` and `score(x)` for further manipulation and analysis. For example:

```{r accessors}
data.frame(b = start(pqs), w = width(pqs), s = score(pqs))
```

By default, `pqsfinder` function reports only the best non-overlapping PQS. However, it's possible to get numbers of all PQS overlapping PQS at each position in input sequence. To achieve that, call `density(x)` function on `PQSViews` object:

```{r density}
density(pqs)
```

The following example than shows, how such density vector could be simply visualized along input sequence using `r Biocpkg('Gviz')` from [Bioconductor].

```{r density_viz, fig.height=1.5, fig.width=8.0, message=FALSE}
library(Gviz)
ss <- DNAStringSet(seq)
names(ss) <- "chr1"
strack <- SequenceTrack(ss, chromosome = "chr1", name = "sequence")
dtrack <- DataTrack(range = IRanges(1:length(density(pqs)*2), width = 2),
                    data = density(pqs), name = "PQS density", chromosome = "chr1")
suppressWarnings(plotTracks(c(dtrack, strack), type = "h"))
```


## Modifying basic algorithm options

Depending on the particular type of quadruplexes you want to detect, the algorithm options can be tuned to find those much more effectively and specifically. The table bellow gives an overview of all basic algorithm options and their description.

Option name      | Description
-----------------|----------------------------------------
`max_len`        | Maximal total length of PQS.
`min_score`      | Minimal score of PQS to be reported.
`run_min_len`    | Minimal length of each PQS run (G-run).
`run_max_len`    | Maximal length of each PQS run.
`loop_min_len`   | Minimal length of each PQS inner loop.
`loop_max_len`   | Maximal length of each PQS inner loop.
`max_bulges`     | Maximal number of runs containing a bulge.
`max_mismatches` | Maximal number of runs containing a mismatch.
`max_defects`    | Maximum number of defects in total (#bulges + #mismatches).

The more you narrow these options in terms of shorter PQS length, narrower run or loop length ranges and lower number of defects, the more high-throughput and more specific the detection process will be.

**Important note:** In each run, the algorithm allows at most one type of defect and at least one run must be perfect, that means without any defect. Therefore the values of `max_bulges`, `max_mismatches` and `max_defects` must fall into the range from 0 to 3.

**Example:** If you are insterested solely in G-quadruplexes with perfect G-runs, just restrict `max_defects` to zero:

```{r perfect_g4, results='hold'}
pqsfinder(seq, max_defects = 0)
```


# Exporting results

## GRanges conversion

## DNAStringSet conversion

# A real world example

# Customizing detection algorithm

The underlying detection algorithm is almost fully customizable, it can even be setup to find fundamentally different types of G-quadruplexes. The very fist option, how to change the detection behavior is to tune scoring bonuses, penalizations and factors. Supported options are summarized in the table bellow:

Option name        | Description
-------------------|--------------------------------------
`tetrad_bonus`     | Score bonus for each G tetrade, regardless the tetrade contains mismatches or not.
`bulge_penalty`    | Penalization for a run with bulge.
`mismatch_penalty` | Penalization for a run with mismatch.
`loop_mean_factor` | Penalization factor of loop lengths mean.
`loop_sd_factor`   | Penalization factor of loop lengths standard deviation.

## Custom scoring function

More complicated way to influence the algorithm output is to implement custom scoring function and pass it throught the `custom_scoring_fn` options. The function should take the following 10 arguments:

* `subject` - input DNAString object,
* `score` - positive PQS score assigned by default internal scoring system, if enabled,
* `start` - PQS start position,
* `width` - PQS width,
* `loop_1` - loop #1 start position,
* `run_2` - run #2 start position,
* `loop_2` - loop #2 start position,
* `run_3` - run #3 start position,
* `loop_3` - loop #3 start position,
* `run_4` - run #4 start position.

Return value of the function has to be new score represented as a single integer value. Please note that if `use_default_scoring` is enabled, the custom scoring function is evaluated **after** the default scoring system (DSS) but **only if** the DSS resulted in positive score (for performance reasons). On the other hand, when `use_default_scoring` is disabled, custom scoring function is evaluated on every PQS.

**Example:** Imagine you would like to take into consideration scoring a metric developed by XXXX in G4Hunter. It can be easily done by defining your custom scoring function:

```{r g4hunter}

```


## Disable default internal scoring

Surely there will be cases when it is undesirable to have the DSS enabled.

Basic interstrand quadruplexes

# Prerequisites

In order to build .Rmd documents the `r CRANpkg("rmarkdown")` package is necessary, which relies on [pandoc](http://johnmacfarlane.net/pandoc/) to compile the final output document. If you are working within a recent version of RStudio then both rmarkdown and pandoc should be already installed.

If you are missing the `r CRANpkg("rmarkdown")` package then you can install it from CRAN using

```{r rmarkdown, eval=FALSE}
install.packages("rmarkdown")
```

In this case a recent version of [pandoc](http://johnmacfarlane.net/pandoc/) (>= 1.12.3) is also required. See the [pandoc installation instructions](https://github.com/rstudio/rmarkdown/blob/master/PANDOC.md) for details on installing pandoc for your platform.


# Authoring R markdown HTML package vignettes

To enable the _Bioconductor_ style in your markdown (`.Rmd`) vignettes you need to:

- Edit to the `DESCRIPTION` file by adding

        VignetteBuilder: knitr
        Suggests: BiocStyle, knitr, rmarkdown

- Specify `BiocStyle::html_document` as the output format and add vignette metadata in the document header:

        ---
        title: "Vignette Title"
        author: "Vignette Author"
        output: 
          BiocStyle::html_document
        vignette: >
          %\VignetteIndexEntry{Vignette Title}
          %\VignetteEngine{knitr::rmarkdown}
          %\VignetteEncoding{UTF-8}  
        ---

The `vignette` section is required in order to instruct R how to build the vignette. Note that the `\VignetteIndexEntry` should match the `title` of your vignette.
  
It is also possible to specify additional details such as:

- document compilation `date` inserted using the helper function `doc_date`
- `package` version specification added by `pkg_ver`
- vignette `abstract`
    
as in the following example. Note the inclusion of an additional style sheet `custom.css` by specifying it in the document header.

```{r code, echo = FALSE}
## The following redefinitions are only for printing the verbatim header below
doc_date = function() "`r doc_date()`"
pkg_ver = function(name) sprintf("`r pkg_ver('%s')`", name)
```

    ---
    title: "Vignette Title"
    author: "Vignette Author"
    date: "`r doc_date()`"
    package: "`r pkg_ver('BiocStyle')`"
    abstract: >
      Vignette Abstract
    vignette: >
      %\VignetteIndexEntry{Vignette Title}
      %\VignetteEngine{knitr::rmarkdown}
      %\VignetteEncoding{UTF-8}
    output: 
      BiocStyle::html_document:
        css: custom.css
    ---


## Use with R markdown v1

Apart from the default markdown engine implemented in the `r CRANpkg('rmarkdown')` package,
it is also possible to compile Bioconductor documents using the older markdown v1 engine 
from the package `r CRANpkg('markdown')`. There are some
differences in setup and the resulting output between these two
engines. 

To use the `r CRANpkg('markdown')` vignette builder engine:

- Add the following to the `DESCRIPTION` file

        VignetteBuilder: knitr
        Suggests: BiocStyle, knitr
        
- Specify the vignette engine in the `.Rmd` files (inside HTML
  comments)

        <!--
        %% \VignetteEngine{knitr::knitr}
        -->

- Add the following code chunk at the beginning of your `.Rmd`
  vignettes

        ```{r style, echo = FALSE, results = 'asis'}`r ''`
        BiocStyle::markdown()
        ```

The way of attaching CSS files when using
`r CRANpkg('markdown')` differs from how this done with `r CRANpkg('rmarkdown')`.
In the former case additional style sheets can be
used by providing them to the `BiocStyle::markdown` function.
To include `custom.css` file use

    ```{r style, echo = FALSE, results = 'asis'}`r ''`
    BiocStyle::markdown(css.files = c('custom.css'))
    ```


# Style macros

```{r macro, echo=FALSE}
macro <- function(name, pkg, description)
    sprintf('`` `r %s("%s")` `` %s %s', name, pkg,
            description, do.call(name, list(pkg)))
```

`r Biocpkg("BiocStyle")` introduces the following macros useful when
referring to _R_ packages:

* `r macro("Biocpkg", "IRanges", "for _Bioconductor_ software, annotation and experiment data packages,
  including a link to the release landing page or if the package is only in devel, to the devel landing page,")`.

* `r macro("CRANpkg", "data.table", "for _R_ packages available on
  CRAN, including a link to the FHCRC CRAN mirror landing page,")`.

* `r macro("Githubpkg", "rstudio/rmarkdown", "for _R_ packages
  available on GitHub, including a link to the package repository,")`.

* `r macro("Rpackage", "MyPkg", "for _R_ packages that are _not_
  available on _Bioconductor_, CRAN or GitHub;")`.


# Additional formatting features

Compared to the default markdown appearance the formatting differences
include:

* Images and tables appear centered, e.g.

    ```{r figure, fig.width=4.0, fig.height=4.4}
    v = seq(0, 60i, length = 1000)
    plot(abs(v)*exp(v), type = "l", col = "Royalblue")
    ``` 
                
* Tables are displayed with striped rows:
    
    ```markdown
    Fruit   | Price
    ------- | -----
    bananas | 1.2
    apples  | 1.0
    oranges | 2.5
    ```
        
    produces

    Fruit   | Price
    ------- | -----
    bananas | 1.2
    apples  | 1.0
    oranges | 2.5

* Paragraph text is justified

* External links open in new browser tab/window

Math symbols can be included in markdown documents. You can write math
expressions the same way you would in `Latex`, except some differences
in escaping them.

- Inline: For inline formulas use `$P(x) = \frac{1}{2}$` or
  `\(P(x) = \frac{1}{2}\)`, which both render as $P(x) = \frac{1}{2}$.

- Standalone: Math can be displayed in a separate line by writing
  `$$P(x) = \frac{1}{2}$$` or `\[P(x) = \frac{1}{2}.\]`, which both
  result in $$P(x) = \frac{1}{2}.$$


# Session info

Here is the output of `sessionInfo()` on the system on which this
document was compiled:

```{r sessionInfo, echo=FALSE}
sessionInfo()
```


[R]: http://r-project.org
[RStudio]: http://www.rstudio.com/
[Bioconductor]: http://www.bioconductor.org/

